---
title: 冒泡排序
date: 2016-08-02 16:54:36
description: 排序算法之冒泡排序
categories: 
- algorithm
tags:
- algorithm
---

# 冒泡排序

冒泡算法是一种简单的交换排序算法，它的平均时间复杂度为O(n^2)，这就导致它在处理大数据量时效率非常低。

## 主要思想
1. 从头开始比较相邻的两个元素，如果它们的顺序与所需的结果相反，则交换它们的位置。
2. 如果该轮比较完，按照步骤1进行下一轮比较

通过每次的比较交换可以发现，大数会逐步移动到后面（假设从小到大排序），可以根据下面的图来理解：
假设待比较的数组为：{5, 1, 12, -5, 16}
![](/assert/algorithm/algorithm-sort-bubble/bubble-sort-1.png)

根据上图，我们可以写出大概的代码：
```java
public void bubble(int[] arrs){
    int tmp;
    int len = arrs.length;
    for (int i = 0; i < len - 1; i++) { // 控制次数
        for (int j = 0; j < len - i - 1; j++) { // 控制相邻的两个数
            if(arrs[j] > arrs[j + 1]){
                tmp = arrs[j];
                arrs[j] = arrs[j + 1];
                arrs[j + 1] = tmp;
            }
        }
    }
}

```

## 复杂度分析
通过以上程序可以看出，它的时间复杂度是O(n^2)，那么有没有情况让时间复杂度再小一点呢？来看下面两个数组：
假设数组为：{2, 3, 4, 5, 1}
![](/assert/algorithm/algorithm-sort-bubble/bubble-sort-2.png)

从图中可以看出，该次排序需要花费O(n^2)才能完成。
假设另一个数组为：{6, 1, 2, 3, 4, 5}
![](/assert/algorithm/algorithm-sort-bubble/bubble-sort-3.png)

可以看出，该次排序其实只需要O(n)就能完成，如果按照之前的程序，将花费不必要的循环和判断。

## 优化
为解决该问题，我们可以添加一个变量来记录在某一轮排序过程中是否交换过数据，则说明数据已经按照要求排列好，程序可以结束，避免不必要的循环比较。
```java
public void bubbleSort3(int[] arrs) {
    boolean swapped = true;
    int j = 0;
    int tmp;
    while (swapped) {
        swapped = false;
        j++;
        for (int i = 0; i < arrs.length - j; i++) {
            if (arrs[i] > arrs[i + 1]) {
                tmp = arrs[i];
                arrs[i] = arrs[i + 1];
                arrs[i + 1] = tmp;
                swapped = true;
            }
        }
    }
}
```

# 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

原始的算法实现在最坏的情况下需要进行O(n^2)的比较和交换。对算法进行少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：
```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：
```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：
```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：
```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```
最后以1步长进行排序（此时就是简单的插入排序了）。

## 步长数列
步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。

Donald Shell最初建议步长选择为 n/2 并且对步长取半直到步长达到1。虽然这样取可以比 O(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。

| 最长序列       | 最坏情况下复杂度         | 
| -------------- | ------------------------ |
| n/2^i          | O(n^2)                   |
| 2^k - 1        | O(n^{3/2})               |
| 2^i 3^j        | O(n log^2 n)             |

已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，该序列的项来自 9 * 4^{i} - 9 * 2{i} + 1和 2^{i+2} * (2^{i+2} - 3) + 1 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。

另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)

```java
public void shellSort(int[] arrs){
    int len = arrs.length, 
        gap = 1, 
        i, j, tmp;
    while(gap < len / 3){ // 确定最大的间隔值
        gap = gap * 3 + 1; // 确保不会丢失元素
    }
    for(; gap > 0; gap /= 3){ // 控制间隔数，需要递减，直至最后一次为1
        for(i = gap; i < len; i++){ // 从间隔数处开始往后
            tmp = arrs[i];
            for(j = i - gap; j >= 0 && arrs[j] > tmp; j -= gap){
                arrs[j + gap] = arrs[j];
            }
            arrs[j + gap] = tmp;
        }
    }	
}
```

## 复杂度分析
选择排序的交换操作介于 0和 (n-1)次之间。选择排序的比较操作为 n(n-1)/2次之间。选择排序的赋值操作介于 0和 3(n-1)次之间。

比较次数 O(n^{2})，比较次数与关键字的初始状态无关，总的比较次数 N=(n-1)+(n-2)+...+1=n * (n-1)/2} 。交换次数 {\displaystyle O(n)} O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

原地操作几乎是选择排序的唯一优点，当方度（space complexity）要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

## 参考
1. [Bubble Sort](http://www.algolist.net/Algorithms/Sorting/Bubble_sort)
2. [希尔排序](https://zh.wikipedia.org/wiki/希尔排序)
